# 学生管理系统 — 前端设计说明

## 一、文档说明

本文档用于说明学生管理系统前端部分的设计方案，涵盖技术实现、架构设计、路由权限逻辑及交互规范，为前端开发提供指导依据。

---

## 二、前端技术栈

基于项目工程化与学习价值的考虑，前端采用现代主流技术栈：

| 技术 | 选型 | 说明 |
| ---- | ---- | ---- |
| 框架 | Vue 3 / React | 核心 UI 构建框架 |
| 构建工具 | Vite | 现代化的前端开发与构建工具 |
| 状态管理 | Pinia / Redux | 用于存储用户信息、Token 及全局状态 |
| 网络请求 | Axios | 封装与后端 /api/v1 接口的交互 |
| UI 组件库 | Element Plus / Ant Design | 提升开发效率的组件库 |
| 路由管理 | Vue Router / React Router | 实现单页应用（SPA）路由跳转 |

---

## 三、目录结构规范

前端项目遵循清晰的模块化结构，便于后期维护与扩展：

```text
src/
├── api/                # 接口请求封装（对应接口说明文档）
│   ├── auth.js         # 认证相关接口
│   ├── user.js         # 用户管理接口
│   ├── majorClass.js   # 专业班级接口
│   ├── courseClass.js  # 课程班级接口
│   └── index.js        # 统一导出
├── assets/             # 静态资源（图片、全局样式）
├── components/         # 公共业务组件
│   ├── common/         # 通用组件（按钮、表格、弹窗）
│   ├── form/           # 表单组件
│   └── layout/         # 布局组件
├── composables/        # 组合式函数（Vue 3）/ hooks（React）
│   ├── useAuth.js      # 认证相关逻辑
│   ├── useBatchOperation.js  # 批量操作逻辑
│   └── usePermission.js      # 权限判断逻辑
├── layout/             # 页面主体布局（侧边栏、顶栏）
├── views/              # 业务页面
│   ├── auth/           # 登录、注册、找回密码
│   ├── student/        # 学生端功能页面
│   ├── teacher/        # 教师端功能页面
│   ├── counselor/      # 辅导员端功能页面
│   └── admin/          # 管理员端功能页面
├── store/              # 全局状态管理
│   ├── modules/        # 状态模块
│   │   ├── auth.js     # 认证状态
│   │   └── app.js      # 应用状态
│   └── index.js        # Store 入口
├── router/             # 路由配置与权限守卫
│   ├── routes/         # 路由配置
│   ├── guards.js       # 路由守卫
│   └── index.js        # 路由入口
├── utils/              # 工具函数
│   ├── request.js      # Axios 封装
│   ├── token.js        # Token 与凭证处理
│   ├── format.js       # 格式化工具
│   └── errorHandler.js # 错误处理
├── constants/          # 常量定义
│   ├── roles.js        # 角色常量
│   ├── errorCodes.js   # 错误码映射
│   └── status.js       # 状态常量
└── styles/             # 全局样式
    ├── variables.scss  # 样式变量
    └── global.scss     # 全局样式
```

---

## 四、路由与权限设计

### 4.1 路由配置

```javascript
// router/routes/index.js
export const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/auth/Login.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/',
    component: Layout,
    meta: { requiresAuth: true },
    children: [
      // 学生路由
      {
        path: 'student/profile',
        name: 'StudentProfile',
        component: () => import('@/views/student/Profile.vue'),
        meta: { roles: ['student'] }
      },
      {
        path: 'student/my-classes',
        name: 'StudentClasses',
        component: () => import('@/views/student/MyClasses.vue'),
        meta: { roles: ['student'] }
      },
      // 教师路由
      {
        path: 'teacher/course-classes',
        name: 'TeacherCourseClasses',
        component: () => import('@/views/teacher/CourseClasses.vue'),
        meta: { roles: ['teacher'] }
      },
      // 辅导员路由
      {
        path: 'counselor/major-classes',
        name: 'CounselorMajorClasses',
        component: () => import('@/views/counselor/MajorClasses.vue'),
        meta: { roles: ['counselor'] }
      },
      // 管理员路由
      {
        path: 'admin/users',
        name: 'AdminUsers',
        component: () => import('@/views/admin/Users.vue'),
        meta: { roles: ['admin'] }
      }
    ]
  }
]
```

### 4.2 路由守卫

```javascript
// router/guards.js
import { useAuthStore } from '@/store/modules/auth'

export function setupRouterGuards(router) {
  router.beforeEach(async (to, from, next) => {
    const authStore = useAuthStore()
    
    // 不需要认证的页面
    if (to.meta.requiresAuth === false) {
      return next()
    }
    
    // 检查登录状态
    if (!authStore.isLoggedIn) {
      return next({ name: 'Login', query: { redirect: to.fullPath } })
    }
    
    // 检查角色权限
    const requiredRoles = to.meta.roles
    if (requiredRoles && !requiredRoles.includes(authStore.userRole)) {
      return next({ name: 'Forbidden' })
    }
    
    next()
  })
}
```

---

## 五、API 请求封装

### 5.1 Axios 实例配置

```javascript
// utils/request.js
import axios from 'axios'
import { getToken, removeToken } from './token'
import { handleErrorCode } from './errorHandler'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 15000
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    const token = getToken()
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)

// 响应拦截器
request.interceptors.response.use(
  response => {
    const { code, message, data } = response.data
    
    // 业务成功
    if (code === 200) {
      return data
    }
    
    // 业务错误，统一处理
    handleErrorCode(code, message)
    return Promise.reject(new Error(message))
  },
  error => {
    // HTTP 错误处理
    if (error.response?.status === 401) {
      removeToken()
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default request
```

### 5.2 错误码处理

```javascript
// utils/errorHandler.js
import { ElMessage } from 'element-plus'
import { ERROR_CODE_MAP } from '@/constants/errorCodes'

export function handleErrorCode(code, message) {
  // 特殊错误码处理
  switch (code) {
    case 40002: // 登录状态失效
      ElMessage.error('登录已过期，请重新登录')
      // 跳转登录页
      break
    case 40001: // 无权限
      ElMessage.error('您没有权限执行此操作')
      break
    default:
      // 显示服务端返回的错误信息
      ElMessage.error(message || ERROR_CODE_MAP[code] || '操作失败')
  }
}
```

### 5.3 错误码常量映射

```javascript
// constants/errorCodes.js
export const ERROR_CODE_MAP = {
  10001: '用户名已存在',
  10002: '用户不存在',
  10003: '密码错误',
  10004: '账号已被禁用',
  10005: '原密码错误',
  10006: '新密码不符合规则',
  10007: '验证码错误或已过期',
  20001: '班级人数已满',
  20002: '班级不存在',
  20004: '班级名称已存在',
  30001: '学生已在该班级中',
  30002: '学生不在该班级中',
  30003: '学生未分配专业班级',
  40001: '无权限执行该操作',
  40002: '登录状态已失效',
  40003: '角色不匹配',
  90001: '参数校验失败',
  90002: '系统内部错误'
}
```

---

## 六、登录与凭证管理

### 6.1 Token 与凭证存储

系统支持"记住密码"功能，根据用户选择决定凭证的存储方式：

```javascript
// utils/token.js
const TOKEN_KEY = 'sms_token'
const REMEMBER_KEY = 'sms_remember'
const USERNAME_KEY = 'sms_username'
const PASSWORD_KEY = 'sms_password'

// 简单的加密/解密函数（用于密码存储，仅做混淆）
const encode = (str) => btoa(encodeURIComponent(str))
const decode = (str) => {
  try {
    return decodeURIComponent(atob(str))
  } catch {
    return ''
  }
}

// 获取 Token（优先 localStorage，其次 sessionStorage）
export function getToken() {
  return localStorage.getItem(TOKEN_KEY) || sessionStorage.getItem(TOKEN_KEY)
}

// 设置 Token
export function setToken(token, remember = false) {
  if (remember) {
    localStorage.setItem(TOKEN_KEY, token)
    sessionStorage.removeItem(TOKEN_KEY)
  } else {
    sessionStorage.setItem(TOKEN_KEY, token)
    localStorage.removeItem(TOKEN_KEY)
  }
}

// 移除 Token
export function removeToken() {
  localStorage.removeItem(TOKEN_KEY)
  sessionStorage.removeItem(TOKEN_KEY)
}

// 保存记住的用户凭证
export function saveRememberedCredentials(username, password) {
  localStorage.setItem(REMEMBER_KEY, 'true')
  localStorage.setItem(USERNAME_KEY, username)
  localStorage.setItem(PASSWORD_KEY, encode(password))
}

// 获取记住的用户凭证
export function getRememberedCredentials() {
  const remembered = localStorage.getItem(REMEMBER_KEY) === 'true'
  const username = localStorage.getItem(USERNAME_KEY) || ''
  const password = decode(localStorage.getItem(PASSWORD_KEY) || '')
  return { remembered, username, password }
}

// 清除记住的用户凭证
export function clearRememberedCredentials() {
  localStorage.removeItem(REMEMBER_KEY)
  localStorage.removeItem(USERNAME_KEY)
  localStorage.removeItem(PASSWORD_KEY)
}
```

### 6.2 记住密码功能说明

| 功能 | 勾选"记住密码" | 不勾选"记住密码" |
| ---- | -------------- | ---------------- |
| Token 存储 | localStorage（持久） | sessionStorage（会话） |
| 用户名存储 | localStorage | 不存储 |
| 密码存储 | localStorage（Base64 编码） | 不存储 |
| 关闭浏览器后 | 保持登录状态 | 需重新登录 |
| 下次打开登录页 | 自动填充用户名和密码 | 需手动输入 |

### 6.3 登录页面实现

```vue
<!-- views/auth/Login.vue -->
<template>
  <div class="login-container">
    <div class="login-card">
      <div class="login-header">
        <h1>学生管理系统</h1>
        <p>Student Management System</p>
      </div>
      
      <el-form ref="formRef" :model="form" :rules="rules" class="login-form">
        <el-form-item prop="username">
          <el-input
            v-model="form.username"
            placeholder="请输入用户名"
            prefix-icon="User"
            size="large"
          />
        </el-form-item>
        
        <el-form-item prop="password">
          <el-input
            v-model="form.password"
            type="password"
            placeholder="请输入密码"
            prefix-icon="Lock"
            size="large"
            show-password
            @keyup.enter="handleLogin"
          />
        </el-form-item>
        
        <el-form-item>
          <div class="form-options">
            <el-checkbox v-model="form.rememberMe">记住密码</el-checkbox>
            <router-link to="/forgot-password" class="forgot-link">
              忘记密码？
            </router-link>
          </div>
        </el-form-item>
        
        <el-form-item>
          <el-button
            type="primary"
            size="large"
            :loading="loading"
            class="login-btn"
            @click="handleLogin"
          >
            {{ loading ? '登录中...' : '登 录' }}
          </el-button>
        </el-form-item>
        
        <div class="register-link">
          还没有账号？
          <router-link to="/register">立即注册</router-link>
        </div>
      </el-form>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { ElMessage } from 'element-plus'
import { useAuthStore } from '@/store'
import { getRememberedCredentials } from '@/utils/token'

const router = useRouter()
const route = useRoute()
const authStore = useAuthStore()

const formRef = ref(null)
const loading = ref(false)

const form = reactive({
  username: '',
  password: '',
  rememberMe: false
})

const rules = {
  username: [{ required: true, message: '请输入用户名', trigger: 'blur' }],
  password: [{ required: true, message: '请输入密码', trigger: 'blur' }]
}

// 页面加载时检查是否有记住的用户凭证
onMounted(() => {
  const { remembered, username, password } = getRememberedCredentials()
  if (remembered) {
    form.username = username
    form.password = password
    form.rememberMe = true
  }
})

const handleLogin = async () => {
  if (!formRef.value) return
  
  try {
    await formRef.value.validate()
    loading.value = true
    
    await authStore.login(form)
    ElMessage.success('登录成功')
    
    const redirect = route.query.redirect || '/'
    router.push(redirect)
  } catch (error) {
    console.error('登录失败:', error)
  } finally {
    loading.value = false
  }
}
</script>
```

### 6.4 认证状态管理

```javascript
// store/modules/auth.js
import { defineStore } from 'pinia'
import { login as loginApi, getCurrentUser, logout as logoutApi } from '@/api/auth'
import { 
  setToken, getToken, removeToken, 
  saveRememberedCredentials, clearRememberedCredentials 
} from '@/utils/token'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: getToken(),
    userInfo: null
  }),
  
  getters: {
    isLoggedIn: state => !!state.token,
    userRole: state => state.userInfo?.role,
    userId: state => state.userInfo?.id
  },
  
  actions: {
    async login(credentials) {
      const { token, userInfo } = await loginApi(credentials)
      this.token = token
      this.userInfo = userInfo
      
      // 根据"记住密码"选项决定存储方式
      const remember = credentials.rememberMe || false
      setToken(token, remember)
      
      // 如果勾选了"记住密码"，保存用户名和密码
      if (remember) {
        saveRememberedCredentials(credentials.username, credentials.password)
      } else {
        clearRememberedCredentials()
      }
    },
    
    async fetchUserInfo() {
      if (!this.token) return
      this.userInfo = await getCurrentUser()
    },
    
    async logout() {
      await logoutApi()
      this.token = null
      this.userInfo = null
      removeToken()
    }
  }
})
```

### 6.5 安全注意事项

> ⚠️ **安全提示**：
> 1. 密码使用 Base64 编码存储在 localStorage 中，仅做简单混淆，不是真正的加密
> 2. 此方案适用于内部系统或对安全要求不高的场景
> 3. 对于高安全要求的系统，建议：
>    - 不存储密码，仅存储用户名
>    - 使用 OAuth2.0 / SSO 等更安全的认证方式
>    - 使用 HttpOnly Cookie 存储 Token

---

## 七、批量操作设计

### 7.1 批量操作组合式函数

```javascript
// composables/useBatchOperation.js
import { ref, computed } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'

export function useBatchOperation(options = {}) {
  const { 
    maxCount = 100,
    confirmTitle = '批量操作确认',
    confirmMessage = '确定要执行此批量操作吗？'
  } = options
  
  const selectedIds = ref([])
  const loading = ref(false)
  
  const hasSelection = computed(() => selectedIds.value.length > 0)
  const selectionCount = computed(() => selectedIds.value.length)
  const isOverLimit = computed(() => selectedIds.value.length > maxCount)
  
  // 处理选择变化
  function handleSelectionChange(selection) {
    selectedIds.value = selection.map(item => item.id)
  }
  
  // 执行批量操作
  async function executeBatch(apiFunction, successMessage = '操作成功') {
    if (!hasSelection.value) {
      ElMessage.warning('请先选择要操作的数据')
      return
    }
    
    if (isOverLimit.value) {
      ElMessage.warning(`最多只能选择 ${maxCount} 条数据`)
      return
    }
    
    try {
      await ElMessageBox.confirm(confirmMessage, confirmTitle, {
        type: 'warning'
      })
      
      loading.value = true
      const result = await apiFunction(selectedIds.value)
      
      // 处理批量操作结果
      if (result.failed > 0) {
        ElMessage.warning(`操作完成：成功 ${result.success} 条，失败 ${result.failed} 条`)
      } else {
        ElMessage.success(`${successMessage}，共 ${result.success} 条`)
      }
      
      // 清空选择
      selectedIds.value = []
      
      return result
    } catch (error) {
      if (error !== 'cancel') {
        ElMessage.error('操作失败')
      }
    } finally {
      loading.value = false
    }
  }
  
  return {
    selectedIds,
    loading,
    hasSelection,
    selectionCount,
    isOverLimit,
    handleSelectionChange,
    executeBatch
  }
}
```

### 7.2 批量操作 API 封装

```javascript
// api/user.js
import request from '@/utils/request'

// 批量创建用户
export function batchCreateUsers(users) {
  return request.post('/users/batch', { users })
}

// 批量获取用户
export function batchGetUsers(ids) {
  return request.post('/users/batch-get', { ids })
}

// 批量删除用户
export function batchDeleteUsers(ids) {
  return request.delete('/users/batch', { data: { ids } })
}
```

---

## 八、页面设计规范

### 8.1 页面布局规范

- **列表页面：** 顶部工具栏 + 筛选区域 + 数据表格 + 分页
- **详情页面：** 面包屑导航 + 详情卡片 + 操作按钮
- **表单页面：** 表单区域 + 提交/取消按钮

### 8.2 交互规范

| 操作类型 | 交互方式 | 说明 |
| -------- | -------- | ---- |
| 新增 | 弹窗/新页面 | 根据表单复杂度选择 |
| 编辑 | 弹窗/新页面 | 与新增保持一致 |
| 删除 | 确认弹窗 | 必须二次确认 |
| 批量删除 | 确认弹窗 | 显示选中数量 |
| 查看详情 | 新页面/抽屉 | 根据信息量选择 |

### 8.3 表单校验规范

```javascript
// 用户表单校验规则示例
const userFormRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, max: 20, message: '用户名长度为 3-20 个字符', trigger: 'blur' },
    { pattern: /^[a-zA-Z0-9_]+$/, message: '用户名只能包含字母、数字和下划线', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 20, message: '密码长度为 6-20 个字符', trigger: 'blur' }
  ],
  realName: [
    { required: true, message: '请输入真实姓名', trigger: 'blur' }
  ],
  email: [
    { type: 'email', message: '请输入正确的邮箱地址', trigger: 'blur' }
  ]
}
```

---

## 九、性能优化建议

### 9.1 请求优化

1. **使用批量接口：** 对于需要获取多条数据的场景，优先使用批量接口
2. **请求合并：** 避免在循环中发起请求，使用批量接口一次性处理
3. **请求缓存：** 对于不常变化的数据（如角色列表），可进行本地缓存
4. **防抖节流：** 搜索输入框使用防抖，滚动加载使用节流

### 9.2 渲染优化

1. **虚拟滚动：** 大数据量列表使用虚拟滚动
2. **懒加载：** 路由组件使用动态导入
3. **按需加载：** UI 组件库按需引入

### 9.3 批量操作最佳实践

```javascript
// ❌ 不推荐：循环请求
async function deleteUsers(ids) {
  for (const id of ids) {
    await deleteUser(id)  // 多次请求
  }
}

// ✅ 推荐：批量请求
async function deleteUsers(ids) {
  await batchDeleteUsers(ids)  // 一次请求
}
```

---

## 十、错误处理规范

### 10.1 全局错误处理

```javascript
// main.js
import { handleErrorCode } from '@/utils/errorHandler'

// Vue 全局错误处理
app.config.errorHandler = (err, vm, info) => {
  console.error('Global error:', err)
  // 上报错误日志
}

// Promise 未捕获错误
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled rejection:', event.reason)
})
```

### 10.2 批量操作错误展示

```vue
<!-- 批量操作结果展示组件 -->
<template>
  <el-dialog v-model="visible" title="操作结果">
    <el-alert 
      v-if="result.failed > 0" 
      type="warning" 
      :title="`成功 ${result.success} 条，失败 ${result.failed} 条`"
    />
    <el-table :data="result.results" v-if="result.failed > 0">
      <el-table-column prop="id" label="ID" />
      <el-table-column prop="status" label="状态">
        <template #default="{ row }">
          <el-tag :type="row.status === 'success' ? 'success' : 'danger'">
            {{ row.status === 'success' ? '成功' : '失败' }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column prop="error.message" label="失败原因" />
    </el-table>
  </el-dialog>
</template>
```

---

## 十一、改进建议汇总

基于当前设计，提出以下改进建议：

### 11.1 架构层面

| 建议项 | 说明 | 优先级 |
| ------ | ---- | ------ |
| 引入 TypeScript | 提升代码可维护性和类型安全 | 高 |
| 统一状态管理 | 使用 Pinia 替代 Vuex（Vue 3） | 高 |
| 组件库按需加载 | 减少打包体积 | 中 |
| 引入单元测试 | 使用 Vitest 进行组件测试 | 中 |

### 11.2 功能层面

| 建议项 | 说明 | 优先级 |
| ------ | ---- | ------ |
| 批量操作进度展示 | 大量数据操作时显示进度条 | 高 |
| 操作日志记录 | 记录用户关键操作 | 中 |
| 数据导入导出 | 支持 Excel 批量导入学生 | 中 |
| 消息通知中心 | 审核结果等消息推送 | 低 |

### 11.3 用户体验

| 建议项 | 说明 | 优先级 |
| ------ | ---- | ------ |
| 骨架屏加载 | 提升首屏加载体验 | 中 |
| 操作反馈优化 | 成功/失败动画效果 | 低 |
| 快捷键支持 | 常用操作快捷键 | 低 |
| 暗色主题 | 支持深色模式 | 低 |

---

## 十二、总结

本前端设计说明文档定义了学生管理系统前端的技术架构、目录结构、路由权限、API 封装、登录凭证管理、批量操作等核心设计方案。

**本次更新要点：**
1. 完善目录结构，增加 composables、constants 等目录
2. 新增"记住密码"功能设计，包含 Token 和凭证的存储策略
3. 新增批量操作设计方案，包含组合式函数和页面示例
4. 增加错误码处理机制，与后端错误码对应
5. 补充性能优化和错误处理规范
6. 提出架构和功能层面的改进建议

开发过程中应遵循本文档规范，确保代码质量和用户体验。